*hotpot* seamless fennel in neovim
>
           dP     dP             dP                       dP
           88     88             88                       88
           88aaaaa88a .d8888b. d8888P 88d888b. .d8888b. d8888P
           88     88  88'  `88   88   88'  `88 88'  `88   88
           88     88  88.  .88   88   88.  .88 88.  .88   88
           dP     dP  `88888P'   dP   88Y888P' `88888P'   dP
                                      88
                                      dP

           You take this home, throw it in a pot, add some
           broth, some neovim...  baby, you got a stew going!

                              ~ Fennel Programmers (probably)

===================================================================== *hotpot-toc*

Purpose...........................................................|hotpot-purpose|
Install...........................................................|hotpot-install|
Setup...............................................................|hotpot-setup|
Usage...............................................................|hotpot-usage|
Hotpot API............................................................|hotpot-api|
Eval Functions.......................................................|hotpot-eval|
  eval-string.................................................|hotpot-eval-string|
  eval-range...................................................|hotpot-eval-range|
  eval-selection...........................................|hotpot-eval-selection|
  eval-buffer.................................................|hotpot-eval-buffer|
  eval-file.....................................................|hotpot-eval-file|
  eval-module.................................................|hotpot-eval-module|
Compile Functions.................................................|hotpot-compile|
  compile-string...........................................|hotpot-compile-string|
  compile-range.............................................|hotpot-compile-range|
  compile-selection.....................................|hotpot-compile-selection|
  compile-buffer...........................................|hotpot-compile-buffer|
  compile-file...............................................|hotpot-compile-file|
  compile-module...........................................|hotpot-compile-module|
Cache Functions.....................................................|hotpot-cache|
  cache-path-for-fnl-file.........................|hotpot-cache-path-for-fnl-file|
  cache-path-for-module.............................|hotpot-cache-path-for-module|
  clear-cache-for-fnl-file.......................|hotpot-clear-cache-for-fnl-file|
  clear-cache-for-module...........................|hotpot-clear-cache-for-module|
  clear-cache.................................................|hotpot-clear-cache|
Log Functions.........................................................|hotpot-log|
  log-path.......................................................|hotpot-log-path|
Commands.........................................................|hotpot-commands|
  :Fnl........................................................|hotpot-command-fnl|
  :Fnldo....................................................|hotpot-command-fnldo|
  :Fnlfile................................................|hotpot-command-fnlfile|
  :source..................................................|hotpot-command-source|
Maps.................................................................|hotpot-maps|
  Operator Pending..........................................|hotpot-operator-eval|
Other Functions...........................................|hotpot-other-functions|
How Hotpot Works......................................................|hotpot-how|

================================================================= *hotpot-purpose*

Purpose ~

Hotpot intends to provide a minimal-setup, unobtrusive fennel compiler, as
well as a set of low level tools for interacting with Fennel code in Neovim
(see |hotpot-api|). It has functions to compile and evaluate Fennel code, but
provides no keymaps to run those functions, or methods of displaying the
output.

Hotpot provides all the tools to build a Fennel REPL but does not provide one.

================================================================= *hotpot-install*

Install ~

Hotpot only needs you to call `require("hotpot")` before you attempt to
require any Fennel files. Afterwards you can require any `fnl/*.fnl` file just
as you would normally require any `lua/*.lua`.

Hotpot will automatically call `require("hotpot")` when
`hotpot/plugin/hotpot.vim` is loaded, but this may occur later than desired,
depending on how you are using Hotpot.

Because of this, it may be preferable to manually require Hotpot as soon as
possible in your `init.lua`. An example `init.lua` is provided below:
>
  -- ~/.config/nvim/init.lua

  -- Pick appropriate path for your package manager

  -- packer
  -- local hotpot_path = vim.fn.stdpath('data') ..
                          '/site/pack/packer/start/hotpot.nvim'
  -- paq
  -- local hotpot_path = vim.fn.stdpath('data') ..
                          '/site/pack/paqs/start/hotpot.nvim'

  -- You can automatically install hotpot if it is missing (i.e for fresh
  -- nvim setups). Don't forget to add hotpot to your package manager or
  -- it may uninstall hotpot!

  if vim.fn.empty(vim.fn.glob(hotpot_path)) > 0 then
    print("Could not find hotpot.nvim, cloning new copy to", hotpot_path)
    vim.fn.system({'git', 'clone',
                   'https://github.com/rktjmp/hotpot.nvim', hotpot_path})
    vim.cmd("helptags " .. hotpot_path .. "/doc")
  end

  -- Bootstrap .fnl support
  require("hotpot")

  -- Now you can load fennel code, so you could put the rest of your
  -- config in a separate `~/.config/nvim/fnl/fenneled_init.fnl` or
  -- `~/.config/nvim/fnl/plugins.fnl`, etc.
  require("fenneled_init")
<
=================================================================== *hotpot-setup*

Setup ~

Hotpot accepts the following configuration options, with defaults as shown.

You do not have to call setup unless you are altering a default option.
>
  require("hotpot").setup({
    provide_require_fennel = false,
    compiler = {
      -- options passed to fennel.compile for modules, defaults to {}
      modules = {
        -- not default but recommended, align lua lines with fnl source
        -- for more debuggable errors, but less readable lua.
        -- correlate = true
      },
      -- options passed to fennel.compile for macros, defaults as shown
      macros = {
        env = "_COMPILER" -- MUST be set along with any other options
      }
    }
  })

`provide_require_fennel` inserts a `package.preload` function that will load
Hotpot's copy of fennel when you call `(require :fennel)`. This can be useful
for ergonomics or for compatibility with libraries that expect Fennel to be in
`package.path`.

`compiler.modules` is passed to the Fennel compiler when compiling regular
module files.

`compiler.macros` is passed to the Fennel compiler when compiling macro files.
Be sure to include `env = "_COMPILER"` unless you have a good reason not to.

Note: the `filename` compilation option is always set to the appropriate value
      and can not be altered via the setup interface.

Note: the `modules` and `macros` tables _replace_ the defaults when given,
      they are _not_ merged. Include all options you wish to pass to the
      compiler!

Note: the `compiler` options are not currently passed to any `api.compile`
      functions and are only applied to Hotpots internal/automatic
      compilation. If you have use for passing options to `api.compile` please
      open an issue.

For a complete list of compiler options, see http://fennel-lang.org,
specifically the API usage section.

=================================================================== *hotpot-usage*

Usage ~

Once Hotpot is installed, you may require any `fnl/.fnl` file as you would a
`lua/.lua` file.
>
  ;; ~/.config/nvim/fnl/is_neat.fnl
  ;; some kind of fennel code
  (fn [what]
    (print what "is neat!"))

  -- and in ~/.config/nvim/init.lua
  local neat = require('is_neat')
  neat("fennel") -- => "fennel is neat!"

===================================================================== *hotpot-api*

Hotpot API ~

Hotpot provides a number of function for evaluating (|hotpot-eval|) and
compiling (|hotpot-compile|) Fennel code, for interacting with its Lua cache and
a set of `:commands` that are similar to the native `:lua` commands
(|hotpot-commands|).

All position arguments are "linewise", starting at 1, 1 for line 1, column 1.
Ranges are end-inclusive.

==================================================================== *hotpot-eval*

Eval Functions ~

Available in the `hotpot.api.eval` module.

The following functions can evaluate Fennel code: from a buffer, file, module
or command.

Every `eval-*` function has the potential to raise an error, by:

  - bad arguments
  - compile errors
  - evaluated code errors

Handling these errors is left to the user.

Note: If your Fennel code does not output anything, running these functions by
      themselves will not show any output! You may wish to wrap them in a
      `(print (eval-* ...))` expression for a simple REPL.

------------------------------------------------------------- *hotpot-eval-string*

`(eval-string string) -> any`

Evaluates a given string.

Accepts

  - `string` of Fennel code

Returns

  - `any`

-------------------------------------------------------------- *hotpot-eval-range*

`(eval-range buf pos pos) -> any`

Evauates a range of text from a buffer.

Accepts

  - `buffer` buffer number
  - `start-pos` line or [line, column]
  - `end-pos` line or [line, column]

Returns

  - `any`

---------------------------------------------------------- *hotpot-eval-selection*

`(eval-selection) -> any`

Evaluates current selection in current buffer.

Accepts

  - `none`

Returns

  - `any`

------------------------------------------------------------- *hotpot-eval-buffer*

`(eval-buffer buf) -> any`

Evaluates contents of buffer.

Accepts

  - `buffer` buffer number

Returns

  - `any`

--------------------------------------------------------------- *hotpot-eval-file*

`(eval-file path) -> any`

Evaluates contents of file on disk.

Accepts

  - `fnl-path` path to `.fnl` file

Returns

  - `any`

------------------------------------------------------------- *hotpot-eval-module*

`(eval-module modname) -> any`

Locates `.fnl` file for corresponding `modname` and evaluates the contents.

Accepts

  - `modname` module name

Returns

  - `any`

================================================================= *hotpot-compile*

Compile Functions ~

Available in the `hotpot.api.compile` module.

The following functions can compile Fennel code, from a buffer, file or
module.

Every `compile-*` function returns `true, luacode` or `false, errors` .

Note: The compiled code is _not_ saved anywhere, nor is it placed in Hotpot's
      cache. To compile into cache, use `require("modname")`.

---------------------------------------------------------- *hotpot-compile-string*

`(compile-string string) -> true luacode | false errors`

Compiles given string containing Fennel code.

Accepts

  - `string` fennel code

Returns

  - `(true luacode)` or `(false errors)`

----------------------------------------------------------- *hotpot-compile-range*

`(compile-range buf pos pos) -> true luacode | false errors`

Compiles given range of buffer.

Accepts

  - `buffer` buffer number
  - `start-pos` line or [line, column]
  - `end-pos` line or [line, column]

Returns

  - `(true luacode)` or `(false errors)`

------------------------------------------------------- *hotpot-compile-selection*

`(compile-selection) -> true luacode | false errors`

Compiles selection in current buffer.

Accepts

  - `none`

Returns

  - `(true luacode)` or `(false errors)`

---------------------------------------------------------- *hotpot-compile-buffer*

`(compile-buffer buf) -> true luacode | false errors`

Compiles given buffer.

Accepts

  - `buffer` buffer number

Returns

  - `(true luacode)` or `(false errors)`

------------------------------------------------------------ *hotpot-compile-file*

`(compile-file path) -> true luacode | false errors`

Compiles given `.fnl` file on disk.

Accepts

  - `fnl-path` path to `.fnl` file

Returns

  - `(true luacode)` or `(false errors)`

---------------------------------------------------------- *hotpot-compile-module*

`(compile-module modname) -> true luacode | false errors`

Locates `.fnl` file for corresponding `modname` and compiles the contents.

Accepts

  - `modname` module name

Returns

  - `(true luacode)` or `(false errors)`

=================================================================== *hotpot-cache*

Cache Functions ~

Available in the `hotpot.api.cache` module.

The following functions can interact with Hotpot's cache.

You can manually interact with the cache at `~/.cache/nvim/hotpot`.

The cache will automatically refresh when required, but note: removing the
cache file is not enough to force recompilation in a running session. The
loaded module must be removed from Lua's `package.loaded` table, then
re-required.
>
  (tset package.loaded :my_module nil) ;; Does NOT unload my_module.child

(Hint: You can iterate `package.loaded` and match the key for `"^my_module"`.)

Note: Some of these functions are destructive, I bear no responsibility for
      any bugs in Hotpot, your OS or the greater cosmos which might have
      caused your files to be destroyed.

------------------------------------------------- *hotpot-cache-path-for-fnl-file*

`(cache-path-for-fnl-file path) -> path | nil`

Locates `.lua` file for corresponding `.fnl` file.

Accepts

  - `fnl-file` absolute path to a `.fnl` file (see |expand| or `fs_realpath`
    from |vim.loop|.)

Returns

  - `path` or `nil` if file does not exist in cache

--------------------------------------------------- *hotpot-cache-path-for-module*

`(cache-path-for-module modname) -> path | nil`

Locates `.lua` file for corresponding `modname`.

Accepts

  - `modname` module name

Returns

  - `path` or `nil` if file does not exist

------------------------------------------------ *hotpot-clear-cache-for-fnl-file*

`(clear-cache-for-fnl-file path) -> true`

Removes corresponding `.lua` file for `.fnl` file if it exists. Does not clear
index record.

Accepts

  - `fnl-file` absolute path to a `.fnl` file (see |expand| or `fs_realpath`
    from |vim.loop|.)

Returns

  - `true`

-------------------------------------------------- *hotpot-clear-cache-for-module*

`(clear-cache-for-module modname) -> true`

Removes corresponding `.lua` file for `modname` if it exists. Will clear index
record.

Accepts

  - `modname` module name

Returns

  - `true`

------------------------------------------------------------- *hotpot-clear-cache*

`(clear-cache) -> true`

Removes all files in Hotpot's cache, including the bytecode index.

Accepts

  - `none`

Returns 

  - `true`

----------------------------------------------------------- *hotpot-cache-prefix*

`(cache-prefix) -> string`

Get path to root of on-disk compiled lua cache folder.

Accepts

  - `none`

Returns

  - `string` path to cache root

===================================================================== *hotpot-log*

Log Functions ~

Available in the `hotpot.api.log` module.

The following functions are helpers to access Hotpot's log file.

You can manually open the log at `~/.cache/nvim/hotpot.log`.

---------------------------------------------------------------- *hotpot-log-path*

`(log-path) -> path`

Get Hotpot's log file path

Accepts

  - `nil`

Returns

  - `string` path to log file

================================================================ *hotpot-commands*

Commands ~

Hotpot provides 3 commands which behave similarly but not exactly like
Neovims Lua commands. See also |lua-commands|.

It also allows the |:source| command to work with `.fnl` files.

-------------------------------------------------------- *:Fnl* *hotpot-command-fnl*

:[range]Fnl {expression}

If evaluates {expression} if provided, othewise evaluates Fennel over [range]
from the current buffer.
>
  :Fnl (print :hello) -> "hello"

  :'<,'> => evaluates selection in current buffer

  :'<,'>Fnl (print :hello) -> "hello" (range is ignored)

---------------------------------------------------- *:Fnldo* *hotpot-command-fnldo*

:[range]Fnldo {expression}

Evaluates {expression} for each line in [range] and replaces each line in
turn. Two variables are availiable inside {expression}, `line` and `linenr`.
>
  :'<,'>Fnldo (string.format "%d: %s" linenr (line:reverse))
  => Prepends line number and reverses the contents of line

------------------------------------------------ *:Fnlfile* *hotpot-command-fnlfile*

:Fnlfile {file}

Evaluates {file}.
>
  :Fnlfile %

  :Fnlfile my-file.fnl

---------------------------------------------------------- *hotpot-command-source*

:source {file}

See |:source|

==================================================================== *hotpot-maps*

Hotpot expects the user to specify most maps themselves via the API functions
listed above. It does provide one `<Plug>` mapping for operator-pending eval.

----------------------------------------------------------- *hotpot-operator-eval*

<Plug>(hotpot-operator-eval)

Enters operator-pending mode and evaluates the Fennel code specifed by the
proceeding motion.
>
  map <Plug> ghe <Plug>(hotpot-operator-eval)

  gheip -> evauate fennel code in paragraph

========================================================= *hotpot-other-functions*

Other Functions ~

_Provisionally spec'd API, consider unstable_

Access to Fennel, available under the `hotpot.api.fennel` module:

- `latest()` returns bundled Fennel, currently always (hopefully) tracks
  latest Fennel release.

===================================================================== *hotpot-how*

How Hotpot Works ~

Hotpot has three main systems, the lua cache, the bytecode cache and the
module loader.

The lua cache contains our compiled fennel code. When requiring a fennel
module, we must first compile that fennel code into lua, then save the result
to disk. This allows the user to easily view the result of the compilation for
debugging. See |hotpot-cache|.

The bytecode cache is a special file (normally called the `index`), loaded
into memory when Neovim starts. It contains the machine readable code for
every module that Neovim has previously loaded. By caching modules in-memory
and in a machine readable format, we can find and resolve modules very quickly
as most of the "heavy lifting" is already done. By maintaining a bytecode
cache we can achieve up to 15x speed improvements.

The bytecode cache contains information about when the cache was created for
each module, so any modifications made to the original source files can be
detected and reloaded into the cache.

The module loader will find and load lua (or fennel) modules. First it will
search the `index` and then Neovims runtime path for source files that match
the requested module name.

If a source file is found, it is compiled to lua (if needed), then the
bytecode is saved to the `index`, then the module is returned to the user.

Given `require("my.module")` Hotpot will check the following locations, in
order, and return the first match.

- `index`
- `$RUNTIMEPATH/lua/my/module.lua`
- `$RUNTIMEPATH/lua/my/module/init.lua`
- `$RUNTIMEPATH/fnl/my/module.fnl`
- `$RUNTIMEPATH/fnl/my/module/init.fnl`
- `package.path/my/module.fnl`

You can see that it will preference a bytecode cache, then `.lua` files over
`.fnl`, if they exist.
